////////////////////////////////////////////////////////////////////////////////
// blonstech
// Copyright(c) 2017 Dominic Bowden
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
////////////////////////////////////////////////////////////////////////////////

#ifndef BLONSTECH_MATH_MATH_H_
#define BLONSTECH_MATH_MATH_H_

// TODO: write own funcs instead of wrapping dxmath
#include <DirectXMath.h>
using namespace DirectX;
// Includes
#include <array>
#include <cstddef>
#include <string.h>
// Public Includes
#include <blons/math/units.h>

namespace blons
{
// Forward declarations
struct Matrix;
struct Vector2;
struct Vector3;
struct Vector4;

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Contains pixel boundaries in the form of X/Y coordinates and
/// width/height dimensions
////////////////////////////////////////////////////////////////////////////////
struct Box
{
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Position and dimensions of the box
    units::subpixel x, y, w, h;
    //@}
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a new box to zero
    ////////////////////////////////////////////////////////////////////////////////
    Box() : x(0), y(0), w(0), h(0) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a new box supplied with subpixel resolution coordinates
    ///
    /// \param _x X coordinate of the new box
    /// \param _y Y coordinate of the new box
    /// \param _w Width of the new box
    /// \param _h Height of the new box
    ////////////////////////////////////////////////////////////////////////////////
    Box(units::subpixel _x, units::subpixel _y, units::subpixel _w, units::subpixel _h) : x(_x), y(_y), w(_w), h(_h) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a new box supplied with pixel coordinates
    ////////////////////////////////////////////////////////////////////////////////
    Box(units::pixel _x, units::pixel _y, units::pixel _w, units::pixel _h) :
        x(units::pixel_to_subpixel(_x)),
        y(units::pixel_to_subpixel(_y)),
        w(units::pixel_to_subpixel(_w)),
        h(units::pixel_to_subpixel(_h)) {}
};

// TODO: Add [] operator for vectors: return *(&x+idx) or something
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief 2D vector containing an X and Y coordinate
////////////////////////////////////////////////////////////////////////////////
struct Vector2
{
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// World coordinates of the vector
    units::world x, y;
    //@}
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to zero
    ////////////////////////////////////////////////////////////////////////////////
    Vector2() : x(0), y(0) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from supplied world units
    ////////////////////////////////////////////////////////////////////////////////
    Vector2(units::world _x, units::world _y) : x(_x), y(_y) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to equal units
    ////////////////////////////////////////////////////////////////////////////////
    Vector2(units::world all) : Vector2(all, all) {}

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Assignment operator
    ////////////////////////////////////////////////////////////////////////////////
    Vector2& operator= (const Vector2& vec);
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Addition operator
    Vector2& operator+= (const Vector2& vec);
    Vector2& operator+= (const units::world& f);
    Vector2 operator+ (const Vector2& vec) const;
    Vector2 operator+ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Subtraction operator
    Vector2& operator-= (const Vector2& vec);
    Vector2& operator-= (const units::world& f);
    Vector2 operator- (const Vector2& vec) const;
    Vector2 operator- (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    Vector2& operator*= (const Vector2& vec);
    Vector2& operator*= (const units::world& f);
    Vector2 operator* (const Vector2& vec) const;
    Vector2 operator* (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Division operator
    Vector2& operator/= (const Vector2& vec);
    Vector2& operator/= (const units::world& f);
    Vector2 operator/ (const Vector2& vec) const;
    Vector2 operator/ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Equality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator== (const Vector2& vec) const;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Inequality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator!= (const Vector2& vec) const;
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief 3D vector containing XYZ coordinates, or optionally RGB if used for
/// colours
////////////////////////////////////////////////////////////////////////////////
struct Vector3
{
    union
    {
        struct { units::world x, y, z; };
        struct { units::world r, g, b; };
    };

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to zero
    ////////////////////////////////////////////////////////////////////////////////
    Vector3() : x(0), y(0), z(0) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from supplied world units
    ////////////////////////////////////////////////////////////////////////////////
    Vector3(units::world _x, units::world _y, units::world _z) : x(_x), y(_y), z(_z) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to equal units
    ////////////////////////////////////////////////////////////////////////////////
    Vector3(units::world all) : Vector3(all, all, all) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from a 4D vector
    ////////////////////////////////////////////////////////////////////////////////
    Vector3(Vector4 v);

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Assignment operator
    ////////////////////////////////////////////////////////////////////////////////
    Vector3& operator= (const Vector3& vec);
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Addition operator
    Vector3& operator+= (const Vector3& vec);
    Vector3& operator+= (const units::world& f);
    Vector3 operator+ (const Vector3& vec) const;
    Vector3 operator+ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Subtraction operator
    Vector3& operator-= (const Vector3& vec);
    Vector3& operator-= (const units::world& f);
    Vector3 operator- (const Vector3& vec) const;
    Vector3 operator- (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    Vector3& operator*= (const Vector3& vec);
    Vector3& operator*= (const units::world& f);
    Vector3& operator*= (const Matrix& mat);
    Vector3 operator* (const Vector3& vec) const;
    Vector3 operator* (const units::world& f) const;
    Vector3 operator* (const Matrix& mat) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Division operator
    Vector3& operator/= (const Vector3& vec);
    Vector3& operator/= (const units::world& f);
    Vector3 operator/ (const Vector3& vec) const;
    Vector3 operator/ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Equality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator== (const Vector3& vec) const;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Inequality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator!= (const Vector3& vec) const;
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief 4D vector containing XYZW coordinates, or optionally RGBA if used for
/// colours
////////////////////////////////////////////////////////////////////////////////
struct Vector4
{
    union
    {
        struct { units::world x, y, z, w; };
        struct { units::world r, g, b, a; };
    };

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to zero
    ////////////////////////////////////////////////////////////////////////////////
    Vector4() : x(0), y(0), z(0), w(0) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from supplied world units
    ////////////////////////////////////////////////////////////////////////////////
    Vector4(units::world _x, units::world _y, units::world _z, units::world _w) : x(_x), y(_y), z(_z), w(_w) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector to equal units
    ////////////////////////////////////////////////////////////////////////////////
    Vector4(units::world all) : Vector4(all, all, all, all) {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from a 3D vector
    ////////////////////////////////////////////////////////////////////////////////
    Vector4(Vector3 v);
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a vector from a Box mapping x -> x, y -> y, width -> z,
    /// and height -> w
    ////////////////////////////////////////////////////////////////////////////////
    Vector4(const Box& b) : x(b.x), y(b.y), z(b.w), w(b.h) {}

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Assignment operator
    ////////////////////////////////////////////////////////////////////////////////
    Vector4& operator= (const Vector4& vec);
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Addition operator
    Vector4& operator+= (const Vector4& vec);
    Vector4& operator+= (const units::world& f);
    Vector4 operator+ (const Vector4& vec) const;
    Vector4 operator+ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Subtraction operator
    Vector4& operator-= (const Vector4& vec);
    Vector4& operator-= (const units::world& f);
    Vector4 operator- (const Vector4& vec) const;
    Vector4 operator- (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    Vector4& operator*= (const Vector4& vec);
    Vector4& operator*= (const units::world& f);
    Vector4& operator*= (const Matrix& mat);
    Vector4 operator* (const Vector4& vec) const;
    Vector4 operator* (const units::world& f) const;
    Vector4 operator* (const Matrix& mat) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Division operator
    Vector4& operator/= (const Vector4& vec);
    Vector4& operator/= (const units::world& f);
    Vector4 operator/ (const Vector4& vec) const;
    Vector4 operator/ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Equality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator== (const Vector4& vec) const;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Inequality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator!= (const Vector4& vec) const;
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief 4x4 row-major matrix containing 16 world units for 3D math
////////////////////////////////////////////////////////////////////////////////
struct Matrix
{
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Vectors of the matrix
    ////////////////////////////////////////////////////////////////////////////////
    units::world m[4][4];

    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes a matrix to zero
    ////////////////////////////////////////////////////////////////////////////////
    Matrix() : m{ 0, 0, 0, 0,
                  0, 0, 0, 0,
                  0, 0, 0, 0,
                  0, 0, 0, 0 } {}

    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Assignment operator
    Matrix& operator=(const Matrix& mat) { memcpy(m, mat.m, sizeof(units::world)*4*4); return *this; }
    // TODO: get rid of this lmao
    Matrix& operator=(const XMFLOAT4X4& xm) { memcpy(m, xm.m, sizeof(units::world)*4*4); return *this; }
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    Matrix& operator*= (const Matrix& mat);
    Matrix operator* (const Matrix& mat) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Equality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator== (const Matrix& matrix) { return memcmp(m, matrix.m, sizeof(units::world)*4*4) == 0; }
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Inequality operator
    ////////////////////////////////////////////////////////////////////////////////
    bool operator!= (const Matrix& matrix) { return !(*this == matrix); }
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates an identity matrix
///
/// \return New identity matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixIdentity();
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates the inverse of a matrix
///
/// \param mat Matrix to invert
/// \return Inverted matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixInverse(Matrix mat);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates a view matrix pointed at a specific coordinate
///
/// \param pos The position you are looking from
/// \param look The position to look at
/// \param up The rotation info of the view
/// \return New view matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixLookAt(Vector3 pos, Vector3 look, Vector3 up);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates an orthographic projection matrix for 2D rendering
///
/// \param left The leftmost position to be rendered on screen
/// \param right The rightmost position to be rendered on screen
/// \param bottom The bottommost position to be rendered on screen
/// \param top The topmost position to be rendered on screen
/// \param screen_near The near clipping plane distance from the camera
/// \param screen_depth The far clipping plane distance from the camera
/// \return Orthographic projection matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixOrthographic(units::world left, units::world right, units::world bottom, units::world top,
                          units::world screen_near, units::world screen_depth);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates a perspective projection matrix for 3D rendering
///
/// \param fov The vertical FOV in radians
/// \param screen_aspect The screen width divided by screen height
/// \param screen_near The near clipping plane distance from the camera
/// \param screen_far The far clipping plane distance from the camera
/// \param zero_to_one Map the near and far values to [0,1] or [-1,1]
/// \return Perspective projection matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixPerspective(float fov, float screen_aspect,
                         units::world screen_near, units::world screen_far,
                         bool zero_to_one);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates a new matrix scaled by the supplied values
///
/// \param x X-axis scaling
/// \param y Y-axis scaling
/// \param z Z-axis scaling
/// \return Scaled matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixScale(units::world x, units::world y, units::world z);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates a new matrix located at the supplied coordinates
///
/// \param x X coordinate of the new matrix
/// \param y Y coordinate of the new matrix
/// \param z Z coordinate of the new matrix
/// \return Translated matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixTranslation(units::world x, units::world y, units::world z);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Transposes the supplied matrix and returns the result
///
/// \param in %Matrix to transpose
/// \return Transposed matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixTranspose(Matrix in);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Generates a view matrix from a given position and rotation
///
/// \param pos Position of the view matrix
/// \param rot Rotation of the view matrix (pitch, yaw, roll)
/// \return Generated view matrix
////////////////////////////////////////////////////////////////////////////////
Matrix MatrixView(Vector3 pos, Vector3 rot);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates the a vector of absolute values from given inputs
///
/// \param v Vector to make absolute
/// \return Calculated absolute vector
////////////////////////////////////////////////////////////////////////////////
Vector3 VectorAbsolute(Vector3 v);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates the cross product of 2 given vectors
///
/// \param a The first vector
/// \param b The second vector
/// \return Calculated cross product
////////////////////////////////////////////////////////////////////////////////
Vector3 VectorCross(Vector3 a, Vector3 b);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates the distance between 2 given vectors
///
/// \param a The first vector
/// \param b The second vector
/// \return Calculated distance
////////////////////////////////////////////////////////////////////////////////
units::world VectorDistance(const Vector3& a, const Vector3& b);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates the dot product of 2 given vectors
///
/// \param a The first vector
/// \param b The second vector
/// \return Calculated dot product
////////////////////////////////////////////////////////////////////////////////
units::world VectorDot(Vector3 a, Vector3 b);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates the length of a given vector
///
/// \param v The vector to measure
/// \return Calculated vector length
////////////////////////////////////////////////////////////////////////////////
units::world VectorLength(Vector3 v);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Normalizes the supplied vector
///
/// \return Normalized vector
////////////////////////////////////////////////////////////////////////////////
Vector3 VectorNormalize(Vector3 n);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Retrieves the rotation info from a view matrix
///
/// \return Vector with rotation info where X is pitch, Y is yaw, and Z is roll
////////////////////////////////////////////////////////////////////////////////
Vector3 VectorPitchYawRoll(Matrix view_matrix);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Contains 2nd order spherical harmonic projections of various
/// functions
////////////////////////////////////////////////////////////////////////////////
struct SHCoeffs2
{
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Raw basis coefficients
    ////////////////////////////////////////////////////////////////////////////////
    units::world coeffs[4];
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes SH coefficients to zero
    ////////////////////////////////////////////////////////////////////////////////
    SHCoeffs2() : coeffs() {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Assignment operator
    ////////////////////////////////////////////////////////////////////////////////
    SHCoeffs2& operator= (const SHCoeffs2& vec);
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Addition operator
    SHCoeffs2& operator+= (const SHCoeffs2& vec);
    SHCoeffs2 operator+ (const SHCoeffs2& vec) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    SHCoeffs2& operator*= (const SHCoeffs2& vec);
    SHCoeffs2& operator*= (const units::world& f);
    SHCoeffs2 operator* (const SHCoeffs2& vec) const;
    SHCoeffs2 operator* (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Division operator
    SHCoeffs2& operator/= (const SHCoeffs2& vec);
    SHCoeffs2& operator/= (const units::world& f);
    SHCoeffs2 operator/ (const SHCoeffs2& vec) const;
    SHCoeffs2 operator/ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Contains 3rd order spherical harmonic projections of various
/// functions
////////////////////////////////////////////////////////////////////////////////
struct SHCoeffs3
{
    ////////////////////////////////////////////////////////////////////////////////
    /// \copydoc SHCoeffs2::coeffs
    ////////////////////////////////////////////////////////////////////////////////
    units::world coeffs[9];
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Initializes SH coefficients to zero
    ////////////////////////////////////////////////////////////////////////////////
    SHCoeffs3() : coeffs() {}
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Assignment operator
    ////////////////////////////////////////////////////////////////////////////////
    SHCoeffs3& operator= (const SHCoeffs3& vec);
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Addition operator
    SHCoeffs3& operator+= (const SHCoeffs3& vec);
    SHCoeffs3 operator+ (const SHCoeffs3& vec) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Multiplication operator
    SHCoeffs3& operator*= (const SHCoeffs3& vec);
    SHCoeffs3& operator*= (const units::world& f);
    SHCoeffs3 operator* (const SHCoeffs3& vec) const;
    SHCoeffs3 operator* (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Division operator
    SHCoeffs3& operator/= (const SHCoeffs3& vec);
    SHCoeffs3& operator/= (const units::world& f);
    SHCoeffs3 operator/ (const SHCoeffs3& vec) const;
    SHCoeffs3 operator/ (const units::world& f) const;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Contains a set of 3 2nd order spherical harmonic projections for each
/// colour channel
////////////////////////////////////////////////////////////////////////////////
struct SHColourCoeffs2
{
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Spherical Harmonics coefficients for the 3 colour channels
    SHCoeffs2 r, g, b;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Contains a set of 3 3rd order spherical harmonic projections for each
/// colour channel
////////////////////////////////////////////////////////////////////////////////
struct SHColourCoeffs3
{
    ////////////////////////////////////////////////////////////////////////////////
    //@{
    /// Spherical Harmonics coefficients for the 3 colour channels
    SHCoeffs3 r, g, b;
    //@}
    ////////////////////////////////////////////////////////////////////////////////
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Calculates spherical harmonic coefficients for a given direction
///
/// \param direction Direction to be projected
/// \return Coefficient representation of direction
////////////////////////////////////////////////////////////////////////////////
SHCoeffs2 SHProjectDirection2(Vector3 direction);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \copydoc SHProjectDirection2
////////////////////////////////////////////////////////////////////////////////
SHCoeffs3 SHProjectDirection3(Vector3 direction);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Defines a basic sphere
////////////////////////////////////////////////////////////////////////////////
struct Sphere
{
    Vector3 center;      ///< Position of the Sphere%'s center
    units::world radius; ///< Radius of the Sphere
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Defines a basic triangle
////////////////////////////////////////////////////////////////////////////////
struct Triangle
{
    std::array<Vector3, 3> vertices; ///< Positions of the 3 vertices that compose this Triangle
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Defines a basic tetrahedron
////////////////////////////////////////////////////////////////////////////////
struct Tetrahedron
{
    std::array<Vector3, 4> vertices; ///< Positions of the 4 vertices that compose this Tetrahedron
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Finds the barycentric coordinates for a position in 3D space within a
/// given Triangle. Assumes point and triangle are coplanar
///
/// \param triangle Triangle in 3D space
/// \param point Position in 3D space to derive barycentric coordiantes from
////////////////////////////////////////////////////////////////////////////////
Vector3 TriangleBarycentric(const Triangle& triangle, const Vector3& point);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Finds the circumsphere of a given Tetrahedron
///
/// \param tetrahedron Tetrahedron in 3D space
////////////////////////////////////////////////////////////////////////////////
Sphere TetrahedronCircumsphere(const Tetrahedron& tetrahedron);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Describes a vector running parallel to a cartesian axis. Used to
/// access AmbientCube coefficients by index
////////////////////////////////////////////////////////////////////////////////
enum AxisAlignedNormal
{
    POSITIVE_X = 0, ///< Positive X direction (1,0,0)
    NEGATIVE_X = 1, ///< Negative X direction (-1,0,0)
    POSITIVE_Y = 2, ///< Positive Y direction (0,1,0)
    NEGATIVE_Y = 3, ///< Negative Y direction (0,-1,0)
    POSITIVE_Z = 4, ///< Positive Z direction (0,0,1)
    NEGATIVE_Z = 5  ///< Negative Z direction (0,0,-1)
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Finds the highest magnitude axis of a supplied vector
///
/// \param direction Vector pointing in the direction to be tested
/// \return Axis of greatest magnitude
////////////////////////////////////////////////////////////////////////////////
AxisAlignedNormal FindGreatestAxis(Vector3 direction);
////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Finds the pitch, yaw, and roll for an AxisAlignedNormal assuming a
/// default rotation pointing towards [0,0,-1]
///
/// \param direction AxisAlignedNormal pointing in the desired direction
/// \return Vector3 containing pitch, yaw, and roll in that order
////////////////////////////////////////////////////////////////////////////////
Vector3 AxisRotationPitchYawRoll(AxisAlignedNormal direction);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Describes directional ambient lighting at a point in space
////////////////////////////////////////////////////////////////////////////////
struct AmbientCube
{
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief 6 coefficients compose an AmbientCube, one for each AxisAlignedNormal
    ////////////////////////////////////////////////////////////////////////////////
    Vector3 coeffs[6];
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Fetches the light value of an AmbientCube for a given direction
///
/// \param cube AmbientCube to sample
/// \param direction Direction to sample from
/// \return RGB colour
////////////////////////////////////////////////////////////////////////////////
Vector3 SampleAmbientCube(const AmbientCube& cube, Vector3 direction);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Holds position, texture coords, and the normal of a single vertex
////////////////////////////////////////////////////////////////////////////////
struct Vertex
{
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Position of the vertex in 3D space
    ////////////////////////////////////////////////////////////////////////////////
    Vector3 pos;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Position of the texture coordinate in 2D space
    ////////////////////////////////////////////////////////////////////////////////
    Vector2 tex;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Position of the lightmap coordinate in 2D space
    ////////////////////////////////////////////////////////////////////////////////
    Vector2 light_tex;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Normalized 3D vector of the surface normal
    ////////////////////////////////////////////////////////////////////////////////
    Vector3 norm;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Normalized 3D vector of the surface tangent
    ////////////////////////////////////////////////////////////////////////////////
    Vector3 tan;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Normalized 3D vector of the surface bitangent
    ////////////////////////////////////////////////////////////////////////////////
    Vector3 bitan;
    ////////////////////////////////////////////////////////////////////////////////
    /// \brief Makes vertices sortable allowing for efficient std::map lookups
    ///
    /// Uses sizeof(units::world) * 10 to avoid comparing tangent and bitangent in a very
    /// hacky, but simple way. This will probably turn into a super nasty bug later.
    ////////////////////////////////////////////////////////////////////////////////
    bool operator< (const Vertex vert) const { return memcmp(this, &vert, sizeof(units::world) * 10) > 0; }
};

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Retrieves the FNV-1a hash of a given block of memory
///
/// \param data Data to be hashed
/// \param size Size of memory in bytes
/// \return 32-bit hash value
////////////////////////////////////////////////////////////////////////////////
unsigned int FastHash(const void* data, std::size_t size);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief Retrieves the FNV-1a hash of a given string
///
/// \param str String to be hashed
/// \return 32-bit hash value
////////////////////////////////////////////////////////////////////////////////
unsigned int FastHash(const char* str);

////////////////////////////////////////////////////////////////////////////////
/// \ingroup math
/// \brief pi. its pi
////////////////////////////////////////////////////////////////////////////////
const float kPi = 3.14159265358979323846f;
} // namespace blons

#endif // BLONSTECH_MATH_MATH_H_